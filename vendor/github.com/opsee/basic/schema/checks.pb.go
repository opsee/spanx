// Code generated by protoc-gen-gogo.
// source: checks.proto
// DO NOT EDIT!

package schema

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import opsee_types "github.com/opsee/protobuf/opseeproto/types"
import opsee_types1 "github.com/opsee/protobuf/opseeproto/types"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/opsee/protobuf/opseeproto"

import github_com_graphql_go_graphql "github.com/graphql-go/graphql"
import github_com_opsee_protobuf_plugin_graphql_scalars "github.com/opsee/protobuf/plugin/graphql/scalars"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Target struct {
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type    string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Id      string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	Address string `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Target) Reset()         { *m = Target{} }
func (m *Target) String() string { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()    {}

type Check struct {
	Id         string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Interval   int32                  `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	Target     *Target                `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	LastRun    *opsee_types.Timestamp `protobuf:"bytes,4,opt,name=last_run" json:"last_run,omitempty"`
	CheckSpec  *opsee_types1.Any      `protobuf:"bytes,5,opt,name=check_spec" json:"check_spec,omitempty"`
	Name       string                 `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	Assertions []*Assertion           `protobuf:"bytes,7,rep,name=assertions" json:"assertions,omitempty"`
	Results    []*CheckResult         `protobuf:"bytes,8,rep,name=results" json:"results,omitempty"`
	// Types that are valid to be assigned to Spec:
	//	*Check_HttpCheck
	//	*Check_CloudwatchCheck
	Spec isCheck_Spec `protobuf_oneof:"spec"`
}

func (m *Check) Reset()         { *m = Check{} }
func (m *Check) String() string { return proto.CompactTextString(m) }
func (*Check) ProtoMessage()    {}

type isCheck_Spec interface {
	isCheck_Spec()
	Equal(interface{}) bool
}

type Check_HttpCheck struct {
	HttpCheck *HttpCheck `protobuf:"bytes,101,opt,name=http_check,oneof"`
}
type Check_CloudwatchCheck struct {
	CloudwatchCheck *CloudWatchCheck `protobuf:"bytes,102,opt,name=cloudwatch_check,oneof"`
}

func (*Check_HttpCheck) isCheck_Spec()       {}
func (*Check_CloudwatchCheck) isCheck_Spec() {}

func (m *Check) GetSpec() isCheck_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Check) GetTarget() *Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Check) GetLastRun() *opsee_types.Timestamp {
	if m != nil {
		return m.LastRun
	}
	return nil
}

func (m *Check) GetCheckSpec() *opsee_types1.Any {
	if m != nil {
		return m.CheckSpec
	}
	return nil
}

func (m *Check) GetAssertions() []*Assertion {
	if m != nil {
		return m.Assertions
	}
	return nil
}

func (m *Check) GetResults() []*CheckResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *Check) GetHttpCheck() *HttpCheck {
	if x, ok := m.GetSpec().(*Check_HttpCheck); ok {
		return x.HttpCheck
	}
	return nil
}

func (m *Check) GetCloudwatchCheck() *CloudWatchCheck {
	if x, ok := m.GetSpec().(*Check_CloudwatchCheck); ok {
		return x.CloudwatchCheck
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Check) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Check_OneofMarshaler, _Check_OneofUnmarshaler, []interface{}{
		(*Check_HttpCheck)(nil),
		(*Check_CloudwatchCheck)(nil),
	}
}

func _Check_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Check)
	// spec
	switch x := m.Spec.(type) {
	case *Check_HttpCheck:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpCheck); err != nil {
			return err
		}
	case *Check_CloudwatchCheck:
		_ = b.EncodeVarint(102<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CloudwatchCheck); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Check.Spec has unexpected type %T", x)
	}
	return nil
}

func _Check_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Check)
	switch tag {
	case 101: // spec.http_check
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpCheck)
		err := b.DecodeMessage(msg)
		m.Spec = &Check_HttpCheck{msg}
		return true, err
	case 102: // spec.cloudwatch_check
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudWatchCheck)
		err := b.DecodeMessage(msg)
		m.Spec = &Check_CloudwatchCheck{msg}
		return true, err
	default:
		return false, nil
	}
}

type Assertion struct {
	// key is one of "code", "header", "body".
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// In the case of key=header, value would be the header field.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// relationship is one of: "equal" "notEqual" "empty" "notEmpty" "contain" "notContain" "regExp"
	Relationship string `protobuf:"bytes,3,opt,name=relationship,proto3" json:"relationship,omitempty"`
	Operand      string `protobuf:"bytes,4,opt,name=operand,proto3" json:"operand,omitempty"`
}

func (m *Assertion) Reset()         { *m = Assertion{} }
func (m *Assertion) String() string { return proto.CompactTextString(m) }
func (*Assertion) ProtoMessage()    {}

type Header struct {
	Name   string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Values []string `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}

type HttpCheck struct {
	Name     string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Path     string    `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Protocol string    `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port     int32     `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty"`
	Verb     string    `protobuf:"bytes,5,opt,name=verb,proto3" json:"verb,omitempty"`
	Headers  []*Header `protobuf:"bytes,6,rep,name=headers" json:"headers,omitempty"`
	Body     string    `protobuf:"bytes,7,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *HttpCheck) Reset()         { *m = HttpCheck{} }
func (m *HttpCheck) String() string { return proto.CompactTextString(m) }
func (*HttpCheck) ProtoMessage()    {}

func (m *HttpCheck) GetHeaders() []*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

type CloudWatchCheck struct {
	// In the case of RDS, id is db instance identifier, name is maybe something
	// we can let them give in UI?
	Target *Target `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	// The AWS CloudWatch metric namespace, e.g. AWS/RDS
	Namespace  string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	MetricName string `protobuf:"bytes,3,opt,name=metric_name,proto3" json:"metric_name,omitempty"`
}

func (m *CloudWatchCheck) Reset()         { *m = CloudWatchCheck{} }
func (m *CloudWatchCheck) String() string { return proto.CompactTextString(m) }
func (*CloudWatchCheck) ProtoMessage()    {}

func (m *CloudWatchCheck) GetTarget() *Target {
	if m != nil {
		return m.Target
	}
	return nil
}

type CloudWatchResponse struct {
	// The AWS CloudWatch metric namespace, e.g. AWS/RDS
	Namespace string    `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Metrics   []*Metric `protobuf:"bytes,2,rep,name=metrics" json:"metrics,omitempty"`
}

func (m *CloudWatchResponse) Reset()         { *m = CloudWatchResponse{} }
func (m *CloudWatchResponse) String() string { return proto.CompactTextString(m) }
func (*CloudWatchResponse) ProtoMessage()    {}

func (m *CloudWatchResponse) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type Metric struct {
	Name      string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value     float64                `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	Tags      []string               `protobuf:"bytes,3,rep,name=tags" json:"tags,omitempty"`
	Timestamp *opsee_types.Timestamp `protobuf:"bytes,4,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}

func (m *Metric) GetTimestamp() *opsee_types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type HttpResponse struct {
	Code    int32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Body    string    `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	Headers []*Header `protobuf:"bytes,3,rep,name=headers" json:"headers,omitempty"`
	Metrics []*Metric `protobuf:"bytes,4,rep,name=metrics" json:"metrics,omitempty"`
	Host    string    `protobuf:"bytes,5,opt,name=host,proto3" json:"host,omitempty"`
}

func (m *HttpResponse) Reset()         { *m = HttpResponse{} }
func (m *HttpResponse) String() string { return proto.CompactTextString(m) }
func (*HttpResponse) ProtoMessage()    {}

func (m *HttpResponse) GetHeaders() []*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *HttpResponse) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type CheckResponse struct {
	Target   *Target           `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	Response *opsee_types1.Any `protobuf:"bytes,2,opt,name=response" json:"response,omitempty"`
	Error    string            `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Passing  bool              `protobuf:"varint,4,opt,name=passing,proto3" json:"passing,omitempty"`
	// Types that are valid to be assigned to Reply:
	//	*CheckResponse_HttpResponse
	//	*CheckResponse_CloudwatchResponse
	Reply isCheckResponse_Reply `protobuf_oneof:"reply"`
}

func (m *CheckResponse) Reset()         { *m = CheckResponse{} }
func (m *CheckResponse) String() string { return proto.CompactTextString(m) }
func (*CheckResponse) ProtoMessage()    {}

type isCheckResponse_Reply interface {
	isCheckResponse_Reply()
	Equal(interface{}) bool
}

type CheckResponse_HttpResponse struct {
	HttpResponse *HttpResponse `protobuf:"bytes,101,opt,name=http_response,oneof"`
}
type CheckResponse_CloudwatchResponse struct {
	CloudwatchResponse *CloudWatchResponse `protobuf:"bytes,102,opt,name=cloudwatch_response,oneof"`
}

func (*CheckResponse_HttpResponse) isCheckResponse_Reply()       {}
func (*CheckResponse_CloudwatchResponse) isCheckResponse_Reply() {}

func (m *CheckResponse) GetReply() isCheckResponse_Reply {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *CheckResponse) GetTarget() *Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *CheckResponse) GetResponse() *opsee_types1.Any {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *CheckResponse) GetHttpResponse() *HttpResponse {
	if x, ok := m.GetReply().(*CheckResponse_HttpResponse); ok {
		return x.HttpResponse
	}
	return nil
}

func (m *CheckResponse) GetCloudwatchResponse() *CloudWatchResponse {
	if x, ok := m.GetReply().(*CheckResponse_CloudwatchResponse); ok {
		return x.CloudwatchResponse
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CheckResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _CheckResponse_OneofMarshaler, _CheckResponse_OneofUnmarshaler, []interface{}{
		(*CheckResponse_HttpResponse)(nil),
		(*CheckResponse_CloudwatchResponse)(nil),
	}
}

func _CheckResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CheckResponse)
	// reply
	switch x := m.Reply.(type) {
	case *CheckResponse_HttpResponse:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpResponse); err != nil {
			return err
		}
	case *CheckResponse_CloudwatchResponse:
		_ = b.EncodeVarint(102<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CloudwatchResponse); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CheckResponse.Reply has unexpected type %T", x)
	}
	return nil
}

func _CheckResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CheckResponse)
	switch tag {
	case 101: // reply.http_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpResponse)
		err := b.DecodeMessage(msg)
		m.Reply = &CheckResponse_HttpResponse{msg}
		return true, err
	case 102: // reply.cloudwatch_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CloudWatchResponse)
		err := b.DecodeMessage(msg)
		m.Reply = &CheckResponse_CloudwatchResponse{msg}
		return true, err
	default:
		return false, nil
	}
}

type CheckResult struct {
	CheckId    string                 `protobuf:"bytes,1,opt,name=check_id,proto3" json:"check_id,omitempty"`
	CustomerId string                 `protobuf:"bytes,2,opt,name=customer_id,proto3" json:"customer_id,omitempty"`
	Timestamp  *opsee_types.Timestamp `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp,omitempty"`
	Passing    bool                   `protobuf:"varint,4,opt,name=passing,proto3" json:"passing,omitempty"`
	Responses  []*CheckResponse       `protobuf:"bytes,5,rep,name=responses" json:"responses,omitempty"`
	Target     *Target                `protobuf:"bytes,6,opt,name=target" json:"target,omitempty"`
	CheckName  string                 `protobuf:"bytes,7,opt,name=check_name,proto3" json:"check_name,omitempty"`
	Version    int32                  `protobuf:"varint,8,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *CheckResult) Reset()         { *m = CheckResult{} }
func (m *CheckResult) String() string { return proto.CompactTextString(m) }
func (*CheckResult) ProtoMessage()    {}

func (m *CheckResult) GetTimestamp() *opsee_types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *CheckResult) GetResponses() []*CheckResponse {
	if m != nil {
		return m.Responses
	}
	return nil
}

func (m *CheckResult) GetTarget() *Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func init() {
	proto.RegisterType((*Target)(nil), "opsee.Target")
	proto.RegisterType((*Check)(nil), "opsee.Check")
	proto.RegisterType((*Assertion)(nil), "opsee.Assertion")
	proto.RegisterType((*Header)(nil), "opsee.Header")
	proto.RegisterType((*HttpCheck)(nil), "opsee.HttpCheck")
	proto.RegisterType((*CloudWatchCheck)(nil), "opsee.CloudWatchCheck")
	proto.RegisterType((*CloudWatchResponse)(nil), "opsee.CloudWatchResponse")
	proto.RegisterType((*Metric)(nil), "opsee.Metric")
	proto.RegisterType((*HttpResponse)(nil), "opsee.HttpResponse")
	proto.RegisterType((*CheckResponse)(nil), "opsee.CheckResponse")
	proto.RegisterType((*CheckResult)(nil), "opsee.CheckResult")
}
func (this *Target) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Target)
	if !ok {
		that2, ok := that.(Target)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	return true
}
func (this *Check) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Check)
	if !ok {
		that2, ok := that.(Check)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Interval != that1.Interval {
		return false
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if !this.LastRun.Equal(that1.LastRun) {
		return false
	}
	if !this.CheckSpec.Equal(that1.CheckSpec) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Assertions) != len(that1.Assertions) {
		return false
	}
	for i := range this.Assertions {
		if !this.Assertions[i].Equal(that1.Assertions[i]) {
			return false
		}
	}
	if len(this.Results) != len(that1.Results) {
		return false
	}
	for i := range this.Results {
		if !this.Results[i].Equal(that1.Results[i]) {
			return false
		}
	}
	if that1.Spec == nil {
		if this.Spec != nil {
			return false
		}
	} else if this.Spec == nil {
		return false
	} else if !this.Spec.Equal(that1.Spec) {
		return false
	}
	return true
}
func (this *Check_HttpCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Check_HttpCheck)
	if !ok {
		that2, ok := that.(Check_HttpCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.HttpCheck.Equal(that1.HttpCheck) {
		return false
	}
	return true
}
func (this *Check_CloudwatchCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Check_CloudwatchCheck)
	if !ok {
		that2, ok := that.(Check_CloudwatchCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CloudwatchCheck.Equal(that1.CloudwatchCheck) {
		return false
	}
	return true
}
func (this *Assertion) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Assertion)
	if !ok {
		that2, ok := that.(Assertion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Relationship != that1.Relationship {
		return false
	}
	if this.Operand != that1.Operand {
		return false
	}
	return true
}
func (this *Header) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Header)
	if !ok {
		that2, ok := that.(Header)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *HttpCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HttpCheck)
	if !ok {
		that2, ok := that.(HttpCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Verb != that1.Verb {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if this.Body != that1.Body {
		return false
	}
	return true
}
func (this *CloudWatchCheck) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CloudWatchCheck)
	if !ok {
		that2, ok := that.(CloudWatchCheck)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.MetricName != that1.MetricName {
		return false
	}
	return true
}
func (this *CloudWatchResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CloudWatchResponse)
	if !ok {
		that2, ok := that.(CloudWatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Metrics) != len(that1.Metrics) {
		return false
	}
	for i := range this.Metrics {
		if !this.Metrics[i].Equal(that1.Metrics[i]) {
			return false
		}
	}
	return true
}
func (this *Metric) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Metric)
	if !ok {
		that2, ok := that.(Metric)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	return true
}
func (this *HttpResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*HttpResponse)
	if !ok {
		that2, ok := that.(HttpResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Body != that1.Body {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.Metrics) != len(that1.Metrics) {
		return false
	}
	for i := range this.Metrics {
		if !this.Metrics[i].Equal(that1.Metrics[i]) {
			return false
		}
	}
	if this.Host != that1.Host {
		return false
	}
	return true
}
func (this *CheckResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckResponse)
	if !ok {
		that2, ok := that.(CheckResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if !this.Response.Equal(that1.Response) {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if this.Passing != that1.Passing {
		return false
	}
	if that1.Reply == nil {
		if this.Reply != nil {
			return false
		}
	} else if this.Reply == nil {
		return false
	} else if !this.Reply.Equal(that1.Reply) {
		return false
	}
	return true
}
func (this *CheckResponse_HttpResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckResponse_HttpResponse)
	if !ok {
		that2, ok := that.(CheckResponse_HttpResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.HttpResponse.Equal(that1.HttpResponse) {
		return false
	}
	return true
}
func (this *CheckResponse_CloudwatchResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckResponse_CloudwatchResponse)
	if !ok {
		that2, ok := that.(CheckResponse_CloudwatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CloudwatchResponse.Equal(that1.CloudwatchResponse) {
		return false
	}
	return true
}
func (this *CheckResult) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CheckResult)
	if !ok {
		that2, ok := that.(CheckResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CheckId != that1.CheckId {
		return false
	}
	if this.CustomerId != that1.CustomerId {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if this.Passing != that1.Passing {
		return false
	}
	if len(this.Responses) != len(that1.Responses) {
		return false
	}
	for i := range this.Responses {
		if !this.Responses[i].Equal(that1.Responses[i]) {
			return false
		}
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if this.CheckName != that1.CheckName {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	return true
}

type TargetGetter interface {
	GetTarget() *Target
}

var GraphQLTargetType *github_com_graphql_go_graphql.Object

type CheckGetter interface {
	GetCheck() *Check
}

var GraphQLCheckType *github_com_graphql_go_graphql.Object
var GraphQLCheckSpecUnion *github_com_graphql_go_graphql.Union

type AssertionGetter interface {
	GetAssertion() *Assertion
}

var GraphQLAssertionType *github_com_graphql_go_graphql.Object

type HeaderGetter interface {
	GetHeader() *Header
}

var GraphQLHeaderType *github_com_graphql_go_graphql.Object

type HttpCheckGetter interface {
	GetHttpCheck() *HttpCheck
}

var GraphQLHttpCheckType *github_com_graphql_go_graphql.Object

type CloudWatchCheckGetter interface {
	GetCloudWatchCheck() *CloudWatchCheck
}

var GraphQLCloudWatchCheckType *github_com_graphql_go_graphql.Object

type CloudWatchResponseGetter interface {
	GetCloudWatchResponse() *CloudWatchResponse
}

var GraphQLCloudWatchResponseType *github_com_graphql_go_graphql.Object

type MetricGetter interface {
	GetMetric() *Metric
}

var GraphQLMetricType *github_com_graphql_go_graphql.Object

type HttpResponseGetter interface {
	GetHttpResponse() *HttpResponse
}

var GraphQLHttpResponseType *github_com_graphql_go_graphql.Object

type CheckResponseGetter interface {
	GetCheckResponse() *CheckResponse
}

var GraphQLCheckResponseType *github_com_graphql_go_graphql.Object
var GraphQLCheckResponseReplyUnion *github_com_graphql_go_graphql.Union

type CheckResultGetter interface {
	GetCheckResult() *CheckResult
}

var GraphQLCheckResultType *github_com_graphql_go_graphql.Object

func (g *Check_HttpCheck) GetHttpCheck() *HttpCheck {
	return g.HttpCheck
}
func (g *Check_CloudwatchCheck) GetCloudWatchCheck() *CloudWatchCheck {
	return g.CloudwatchCheck
}
func (g *CheckResponse_HttpResponse) GetHttpResponse() *HttpResponse {
	return g.HttpResponse
}
func (g *CheckResponse_CloudwatchResponse) GetCloudWatchResponse() *CloudWatchResponse {
	return g.CloudwatchResponse
}

func init() {
	GraphQLTargetType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaTarget",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Target)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(TargetGetter)
						if ok {
							face := inter.GetTarget()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"type": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Target)
						if ok {
							return obj.Type, nil
						}
						inter, ok := p.Source.(TargetGetter)
						if ok {
							face := inter.GetTarget()
							if face == nil {
								return nil, nil
							}
							return face.Type, nil
						}
						return nil, fmt.Errorf("field type not resolved")
					},
				},
				"id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Target)
						if ok {
							return obj.Id, nil
						}
						inter, ok := p.Source.(TargetGetter)
						if ok {
							face := inter.GetTarget()
							if face == nil {
								return nil, nil
							}
							return face.Id, nil
						}
						return nil, fmt.Errorf("field id not resolved")
					},
				},
				"address": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Target)
						if ok {
							return obj.Address, nil
						}
						inter, ok := p.Source.(TargetGetter)
						if ok {
							face := inter.GetTarget()
							if face == nil {
								return nil, nil
							}
							return face.Address, nil
						}
						return nil, fmt.Errorf("field address not resolved")
					},
				},
			}
		}),
	})
	GraphQLCheckType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCheck",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Id, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Id, nil
						}
						return nil, fmt.Errorf("field id not resolved")
					},
				},
				"interval": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Interval, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Interval, nil
						}
						return nil, fmt.Errorf("field interval not resolved")
					},
				},
				"target": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLTargetType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							if obj.Target == nil {
								return nil, nil
							}
							return obj.GetTarget(), nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							if face.Target == nil {
								return nil, nil
							}
							return face.GetTarget(), nil
						}
						return nil, fmt.Errorf("field target not resolved")
					},
				},
				"last_run": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							if obj.LastRun == nil {
								return nil, nil
							}
							return obj.GetLastRun(), nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							if face.LastRun == nil {
								return nil, nil
							}
							return face.GetLastRun(), nil
						}
						return nil, fmt.Errorf("field last_run not resolved")
					},
				},
				"check_spec": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Any,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							if obj.CheckSpec == nil {
								return nil, nil
							}
							return obj.GetCheckSpec(), nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							if face.CheckSpec == nil {
								return nil, nil
							}
							return face.GetCheckSpec(), nil
						}
						return nil, fmt.Errorf("field check_spec not resolved")
					},
				},
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"assertions": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLAssertionType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Assertions, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Assertions, nil
						}
						return nil, fmt.Errorf("field assertions not resolved")
					},
				},
				"results": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLCheckResultType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if ok {
							return obj.Results, nil
						}
						inter, ok := p.Source.(CheckGetter)
						if ok {
							face := inter.GetCheck()
							if face == nil {
								return nil, nil
							}
							return face.Results, nil
						}
						return nil, fmt.Errorf("field results not resolved")
					},
				},
				"spec": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLCheckSpecUnion,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Check)
						if !ok {
							return nil, fmt.Errorf("field spec not resolved")
						}
						return obj.GetSpec(), nil
					},
				},
			}
		}),
	})
	GraphQLAssertionType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaAssertion",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"key": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "key is one of \"code\", \"header\", \"body\".",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Assertion)
						if ok {
							return obj.Key, nil
						}
						inter, ok := p.Source.(AssertionGetter)
						if ok {
							face := inter.GetAssertion()
							if face == nil {
								return nil, nil
							}
							return face.Key, nil
						}
						return nil, fmt.Errorf("field key not resolved")
					},
				},
				"value": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "In the case of key=header, value would be the header field.",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Assertion)
						if ok {
							return obj.Value, nil
						}
						inter, ok := p.Source.(AssertionGetter)
						if ok {
							face := inter.GetAssertion()
							if face == nil {
								return nil, nil
							}
							return face.Value, nil
						}
						return nil, fmt.Errorf("field value not resolved")
					},
				},
				"relationship": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "relationship is one of: \"equal\" \"notEqual\" \"empty\" \"notEmpty\" \"contain\" \"notContain\" \"regExp\"",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Assertion)
						if ok {
							return obj.Relationship, nil
						}
						inter, ok := p.Source.(AssertionGetter)
						if ok {
							face := inter.GetAssertion()
							if face == nil {
								return nil, nil
							}
							return face.Relationship, nil
						}
						return nil, fmt.Errorf("field relationship not resolved")
					},
				},
				"operand": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Assertion)
						if ok {
							return obj.Operand, nil
						}
						inter, ok := p.Source.(AssertionGetter)
						if ok {
							face := inter.GetAssertion()
							if face == nil {
								return nil, nil
							}
							return face.Operand, nil
						}
						return nil, fmt.Errorf("field operand not resolved")
					},
				},
			}
		}),
	})
	GraphQLHeaderType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaHeader",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Header)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(HeaderGetter)
						if ok {
							face := inter.GetHeader()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"values": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Header)
						if ok {
							return obj.Values, nil
						}
						inter, ok := p.Source.(HeaderGetter)
						if ok {
							face := inter.GetHeader()
							if face == nil {
								return nil, nil
							}
							return face.Values, nil
						}
						return nil, fmt.Errorf("field values not resolved")
					},
				},
			}
		}),
	})
	GraphQLHttpCheckType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaHttpCheck",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"path": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Path, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Path, nil
						}
						return nil, fmt.Errorf("field path not resolved")
					},
				},
				"protocol": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Protocol, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Protocol, nil
						}
						return nil, fmt.Errorf("field protocol not resolved")
					},
				},
				"port": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Port, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Port, nil
						}
						return nil, fmt.Errorf("field port not resolved")
					},
				},
				"verb": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Verb, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Verb, nil
						}
						return nil, fmt.Errorf("field verb not resolved")
					},
				},
				"headers": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLHeaderType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Headers, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Headers, nil
						}
						return nil, fmt.Errorf("field headers not resolved")
					},
				},
				"body": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpCheck)
						if ok {
							return obj.Body, nil
						}
						inter, ok := p.Source.(HttpCheckGetter)
						if ok {
							face := inter.GetHttpCheck()
							if face == nil {
								return nil, nil
							}
							return face.Body, nil
						}
						return nil, fmt.Errorf("field body not resolved")
					},
				},
			}
		}),
	})
	GraphQLCloudWatchCheckType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCloudWatchCheck",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"target": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLTargetType,
					Description: "In the case of RDS, id is db instance identifier, name is maybe something\n we can let them give in UI?",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchCheck)
						if ok {
							if obj.Target == nil {
								return nil, nil
							}
							return obj.GetTarget(), nil
						}
						inter, ok := p.Source.(CloudWatchCheckGetter)
						if ok {
							face := inter.GetCloudWatchCheck()
							if face == nil {
								return nil, nil
							}
							if face.Target == nil {
								return nil, nil
							}
							return face.GetTarget(), nil
						}
						return nil, fmt.Errorf("field target not resolved")
					},
				},
				"namespace": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The AWS CloudWatch metric namespace, e.g. AWS/RDS",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchCheck)
						if ok {
							return obj.Namespace, nil
						}
						inter, ok := p.Source.(CloudWatchCheckGetter)
						if ok {
							face := inter.GetCloudWatchCheck()
							if face == nil {
								return nil, nil
							}
							return face.Namespace, nil
						}
						return nil, fmt.Errorf("field namespace not resolved")
					},
				},
				"metric_name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchCheck)
						if ok {
							return obj.MetricName, nil
						}
						inter, ok := p.Source.(CloudWatchCheckGetter)
						if ok {
							face := inter.GetCloudWatchCheck()
							if face == nil {
								return nil, nil
							}
							return face.MetricName, nil
						}
						return nil, fmt.Errorf("field metric_name not resolved")
					},
				},
			}
		}),
	})
	GraphQLCloudWatchResponseType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCloudWatchResponse",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"namespace": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The AWS CloudWatch metric namespace, e.g. AWS/RDS",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchResponse)
						if ok {
							return obj.Namespace, nil
						}
						inter, ok := p.Source.(CloudWatchResponseGetter)
						if ok {
							face := inter.GetCloudWatchResponse()
							if face == nil {
								return nil, nil
							}
							return face.Namespace, nil
						}
						return nil, fmt.Errorf("field namespace not resolved")
					},
				},
				"metrics": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLMetricType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CloudWatchResponse)
						if ok {
							return obj.Metrics, nil
						}
						inter, ok := p.Source.(CloudWatchResponseGetter)
						if ok {
							face := inter.GetCloudWatchResponse()
							if face == nil {
								return nil, nil
							}
							return face.Metrics, nil
						}
						return nil, fmt.Errorf("field metrics not resolved")
					},
				},
			}
		}),
	})
	GraphQLMetricType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaMetric",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Metric)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(MetricGetter)
						if ok {
							face := inter.GetMetric()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"value": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Float,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Metric)
						if ok {
							return obj.Value, nil
						}
						inter, ok := p.Source.(MetricGetter)
						if ok {
							face := inter.GetMetric()
							if face == nil {
								return nil, nil
							}
							return face.Value, nil
						}
						return nil, fmt.Errorf("field value not resolved")
					},
				},
				"tags": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(github_com_graphql_go_graphql.String),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Metric)
						if ok {
							return obj.Tags, nil
						}
						inter, ok := p.Source.(MetricGetter)
						if ok {
							face := inter.GetMetric()
							if face == nil {
								return nil, nil
							}
							return face.Tags, nil
						}
						return nil, fmt.Errorf("field tags not resolved")
					},
				},
				"timestamp": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Metric)
						if ok {
							if obj.Timestamp == nil {
								return nil, nil
							}
							return obj.GetTimestamp(), nil
						}
						inter, ok := p.Source.(MetricGetter)
						if ok {
							face := inter.GetMetric()
							if face == nil {
								return nil, nil
							}
							if face.Timestamp == nil {
								return nil, nil
							}
							return face.GetTimestamp(), nil
						}
						return nil, fmt.Errorf("field timestamp not resolved")
					},
				},
			}
		}),
	})
	GraphQLHttpResponseType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaHttpResponse",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"code": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpResponse)
						if ok {
							return obj.Code, nil
						}
						inter, ok := p.Source.(HttpResponseGetter)
						if ok {
							face := inter.GetHttpResponse()
							if face == nil {
								return nil, nil
							}
							return face.Code, nil
						}
						return nil, fmt.Errorf("field code not resolved")
					},
				},
				"body": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpResponse)
						if ok {
							return obj.Body, nil
						}
						inter, ok := p.Source.(HttpResponseGetter)
						if ok {
							face := inter.GetHttpResponse()
							if face == nil {
								return nil, nil
							}
							return face.Body, nil
						}
						return nil, fmt.Errorf("field body not resolved")
					},
				},
				"headers": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLHeaderType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpResponse)
						if ok {
							return obj.Headers, nil
						}
						inter, ok := p.Source.(HttpResponseGetter)
						if ok {
							face := inter.GetHttpResponse()
							if face == nil {
								return nil, nil
							}
							return face.Headers, nil
						}
						return nil, fmt.Errorf("field headers not resolved")
					},
				},
				"metrics": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLMetricType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpResponse)
						if ok {
							return obj.Metrics, nil
						}
						inter, ok := p.Source.(HttpResponseGetter)
						if ok {
							face := inter.GetHttpResponse()
							if face == nil {
								return nil, nil
							}
							return face.Metrics, nil
						}
						return nil, fmt.Errorf("field metrics not resolved")
					},
				},
				"host": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*HttpResponse)
						if ok {
							return obj.Host, nil
						}
						inter, ok := p.Source.(HttpResponseGetter)
						if ok {
							face := inter.GetHttpResponse()
							if face == nil {
								return nil, nil
							}
							return face.Host, nil
						}
						return nil, fmt.Errorf("field host not resolved")
					},
				},
			}
		}),
	})
	GraphQLCheckResponseType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCheckResponse",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"target": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLTargetType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResponse)
						if ok {
							if obj.Target == nil {
								return nil, nil
							}
							return obj.GetTarget(), nil
						}
						inter, ok := p.Source.(CheckResponseGetter)
						if ok {
							face := inter.GetCheckResponse()
							if face == nil {
								return nil, nil
							}
							if face.Target == nil {
								return nil, nil
							}
							return face.GetTarget(), nil
						}
						return nil, fmt.Errorf("field target not resolved")
					},
				},
				"response": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Any,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResponse)
						if ok {
							if obj.Response == nil {
								return nil, nil
							}
							return obj.GetResponse(), nil
						}
						inter, ok := p.Source.(CheckResponseGetter)
						if ok {
							face := inter.GetCheckResponse()
							if face == nil {
								return nil, nil
							}
							if face.Response == nil {
								return nil, nil
							}
							return face.GetResponse(), nil
						}
						return nil, fmt.Errorf("field response not resolved")
					},
				},
				"error": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResponse)
						if ok {
							return obj.Error, nil
						}
						inter, ok := p.Source.(CheckResponseGetter)
						if ok {
							face := inter.GetCheckResponse()
							if face == nil {
								return nil, nil
							}
							return face.Error, nil
						}
						return nil, fmt.Errorf("field error not resolved")
					},
				},
				"passing": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResponse)
						if ok {
							return obj.Passing, nil
						}
						inter, ok := p.Source.(CheckResponseGetter)
						if ok {
							face := inter.GetCheckResponse()
							if face == nil {
								return nil, nil
							}
							return face.Passing, nil
						}
						return nil, fmt.Errorf("field passing not resolved")
					},
				},
				"reply": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLCheckResponseReplyUnion,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResponse)
						if !ok {
							return nil, fmt.Errorf("field reply not resolved")
						}
						return obj.GetReply(), nil
					},
				},
			}
		}),
	})
	GraphQLCheckResultType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "schemaCheckResult",
		Description: "",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"check_id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.CheckId, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.CheckId, nil
						}
						return nil, fmt.Errorf("field check_id not resolved")
					},
				},
				"customer_id": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.CustomerId, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.CustomerId, nil
						}
						return nil, fmt.Errorf("field customer_id not resolved")
					},
				},
				"timestamp": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							if obj.Timestamp == nil {
								return nil, nil
							}
							return obj.GetTimestamp(), nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							if face.Timestamp == nil {
								return nil, nil
							}
							return face.GetTimestamp(), nil
						}
						return nil, fmt.Errorf("field timestamp not resolved")
					},
				},
				"passing": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Boolean,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.Passing, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.Passing, nil
						}
						return nil, fmt.Errorf("field passing not resolved")
					},
				},
				"responses": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLCheckResponseType),
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.Responses, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.Responses, nil
						}
						return nil, fmt.Errorf("field responses not resolved")
					},
				},
				"target": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLTargetType,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							if obj.Target == nil {
								return nil, nil
							}
							return obj.GetTarget(), nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							if face.Target == nil {
								return nil, nil
							}
							return face.GetTarget(), nil
						}
						return nil, fmt.Errorf("field target not resolved")
					},
				},
				"check_name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.CheckName, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.CheckName, nil
						}
						return nil, fmt.Errorf("field check_name not resolved")
					},
				},
				"version": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*CheckResult)
						if ok {
							return obj.Version, nil
						}
						inter, ok := p.Source.(CheckResultGetter)
						if ok {
							face := inter.GetCheckResult()
							if face == nil {
								return nil, nil
							}
							return face.Version, nil
						}
						return nil, fmt.Errorf("field version not resolved")
					},
				},
			}
		}),
	})
	GraphQLCheckSpecUnion = github_com_graphql_go_graphql.NewUnion(github_com_graphql_go_graphql.UnionConfig{
		Name:        "CheckSpec",
		Description: "",
		Types: []*github_com_graphql_go_graphql.Object{
			GraphQLHttpCheckType,
			GraphQLCloudWatchCheckType,
		},
		ResolveType: func(value interface{}, info github_com_graphql_go_graphql.ResolveInfo) *github_com_graphql_go_graphql.Object {
			switch value.(type) {
			case *Check_HttpCheck:
				return GraphQLHttpCheckType
			case *Check_CloudwatchCheck:
				return GraphQLCloudWatchCheckType
			}
			return nil
		},
	})
	GraphQLCheckResponseReplyUnion = github_com_graphql_go_graphql.NewUnion(github_com_graphql_go_graphql.UnionConfig{
		Name:        "CheckResponseReply",
		Description: "",
		Types: []*github_com_graphql_go_graphql.Object{
			GraphQLHttpResponseType,
			GraphQLCloudWatchResponseType,
		},
		ResolveType: func(value interface{}, info github_com_graphql_go_graphql.ResolveInfo) *github_com_graphql_go_graphql.Object {
			switch value.(type) {
			case *CheckResponse_HttpResponse:
				return GraphQLHttpResponseType
			case *CheckResponse_CloudwatchResponse:
				return GraphQLCloudWatchResponseType
			}
			return nil
		},
	})
}
func NewPopulatedTarget(r randyChecks, easy bool) *Target {
	this := &Target{}
	this.Name = randStringChecks(r)
	this.Type = randStringChecks(r)
	this.Id = randStringChecks(r)
	this.Address = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheck(r randyChecks, easy bool) *Check {
	this := &Check{}
	this.Id = randStringChecks(r)
	this.Interval = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Interval *= -1
	}
	if r.Intn(10) != 0 {
		this.Target = NewPopulatedTarget(r, easy)
	}
	if r.Intn(10) != 0 {
		this.LastRun = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.CheckSpec = opsee_types1.NewPopulatedAny(r, easy)
	}
	this.Name = randStringChecks(r)
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Assertions = make([]*Assertion, v1)
		for i := 0; i < v1; i++ {
			this.Assertions[i] = NewPopulatedAssertion(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.Results = make([]*CheckResult, v2)
		for i := 0; i < v2; i++ {
			this.Results[i] = NewPopulatedCheckResult(r, easy)
		}
	}
	oneofNumber_Spec := []int32{101, 102}[r.Intn(2)]
	switch oneofNumber_Spec {
	case 101:
		this.Spec = NewPopulatedCheck_HttpCheck(r, easy)
	case 102:
		this.Spec = NewPopulatedCheck_CloudwatchCheck(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheck_HttpCheck(r randyChecks, easy bool) *Check_HttpCheck {
	this := &Check_HttpCheck{}
	this.HttpCheck = NewPopulatedHttpCheck(r, easy)
	return this
}
func NewPopulatedCheck_CloudwatchCheck(r randyChecks, easy bool) *Check_CloudwatchCheck {
	this := &Check_CloudwatchCheck{}
	this.CloudwatchCheck = NewPopulatedCloudWatchCheck(r, easy)
	return this
}
func NewPopulatedAssertion(r randyChecks, easy bool) *Assertion {
	this := &Assertion{}
	this.Key = randStringChecks(r)
	this.Value = randStringChecks(r)
	this.Relationship = randStringChecks(r)
	this.Operand = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHeader(r randyChecks, easy bool) *Header {
	this := &Header{}
	this.Name = randStringChecks(r)
	v3 := r.Intn(10)
	this.Values = make([]string, v3)
	for i := 0; i < v3; i++ {
		this.Values[i] = randStringChecks(r)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHttpCheck(r randyChecks, easy bool) *HttpCheck {
	this := &HttpCheck{}
	this.Name = randStringChecks(r)
	this.Path = randStringChecks(r)
	this.Protocol = randStringChecks(r)
	this.Port = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Port *= -1
	}
	this.Verb = randStringChecks(r)
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.Headers = make([]*Header, v4)
		for i := 0; i < v4; i++ {
			this.Headers[i] = NewPopulatedHeader(r, easy)
		}
	}
	this.Body = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCloudWatchCheck(r randyChecks, easy bool) *CloudWatchCheck {
	this := &CloudWatchCheck{}
	if r.Intn(10) != 0 {
		this.Target = NewPopulatedTarget(r, easy)
	}
	this.Namespace = randStringChecks(r)
	this.MetricName = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCloudWatchResponse(r randyChecks, easy bool) *CloudWatchResponse {
	this := &CloudWatchResponse{}
	this.Namespace = randStringChecks(r)
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.Metrics = make([]*Metric, v5)
		for i := 0; i < v5; i++ {
			this.Metrics[i] = NewPopulatedMetric(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMetric(r randyChecks, easy bool) *Metric {
	this := &Metric{}
	this.Name = randStringChecks(r)
	this.Value = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Value *= -1
	}
	v6 := r.Intn(10)
	this.Tags = make([]string, v6)
	for i := 0; i < v6; i++ {
		this.Tags[i] = randStringChecks(r)
	}
	if r.Intn(10) != 0 {
		this.Timestamp = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedHttpResponse(r randyChecks, easy bool) *HttpResponse {
	this := &HttpResponse{}
	this.Code = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Code *= -1
	}
	this.Body = randStringChecks(r)
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.Headers = make([]*Header, v7)
		for i := 0; i < v7; i++ {
			this.Headers[i] = NewPopulatedHeader(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.Metrics = make([]*Metric, v8)
		for i := 0; i < v8; i++ {
			this.Metrics[i] = NewPopulatedMetric(r, easy)
		}
	}
	this.Host = randStringChecks(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckResponse(r randyChecks, easy bool) *CheckResponse {
	this := &CheckResponse{}
	if r.Intn(10) != 0 {
		this.Target = NewPopulatedTarget(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Response = opsee_types1.NewPopulatedAny(r, easy)
	}
	this.Error = randStringChecks(r)
	this.Passing = bool(bool(r.Intn(2) == 0))
	oneofNumber_Reply := []int32{101, 102}[r.Intn(2)]
	switch oneofNumber_Reply {
	case 101:
		this.Reply = NewPopulatedCheckResponse_HttpResponse(r, easy)
	case 102:
		this.Reply = NewPopulatedCheckResponse_CloudwatchResponse(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCheckResponse_HttpResponse(r randyChecks, easy bool) *CheckResponse_HttpResponse {
	this := &CheckResponse_HttpResponse{}
	this.HttpResponse = NewPopulatedHttpResponse(r, easy)
	return this
}
func NewPopulatedCheckResponse_CloudwatchResponse(r randyChecks, easy bool) *CheckResponse_CloudwatchResponse {
	this := &CheckResponse_CloudwatchResponse{}
	this.CloudwatchResponse = NewPopulatedCloudWatchResponse(r, easy)
	return this
}
func NewPopulatedCheckResult(r randyChecks, easy bool) *CheckResult {
	this := &CheckResult{}
	this.CheckId = randStringChecks(r)
	this.CustomerId = randStringChecks(r)
	if r.Intn(10) != 0 {
		this.Timestamp = opsee_types.NewPopulatedTimestamp(r, easy)
	}
	this.Passing = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.Responses = make([]*CheckResponse, v9)
		for i := 0; i < v9; i++ {
			this.Responses[i] = NewPopulatedCheckResponse(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Target = NewPopulatedTarget(r, easy)
	}
	this.CheckName = randStringChecks(r)
	this.Version = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Version *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyChecks interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneChecks(r randyChecks) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringChecks(r randyChecks) string {
	v10 := r.Intn(100)
	tmps := make([]rune, v10)
	for i := 0; i < v10; i++ {
		tmps[i] = randUTF8RuneChecks(r)
	}
	return string(tmps)
}
func randUnrecognizedChecks(r randyChecks, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldChecks(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldChecks(data []byte, r randyChecks, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateChecks(data, uint64(key))
		v11 := r.Int63()
		if r.Intn(2) == 0 {
			v11 *= -1
		}
		data = encodeVarintPopulateChecks(data, uint64(v11))
	case 1:
		data = encodeVarintPopulateChecks(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateChecks(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateChecks(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateChecks(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateChecks(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
